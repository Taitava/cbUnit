

// Copied 2021-02-12 from http://www.cbrepository.com/codes/code/87/
// Created 2013-09-20 by Jare
// Modifications: Made the function FVD compatible
Function PatternCompare(pattern$, compare$, case_sensitive=1, wildcard$="*", escape$="\")
	Dim position, count_bits, i, bit$ // Force Variable Declaration
	
    position = 1
    If Not case_sensitive Then
        pattern = Lower(pattern)
        compare = Lower(compare)
    EndIf
    If escape <> "" Then
        pattern = Replace(pattern, escape+escape, Chr(1))
        pattern = Replace(pattern, escape+wildcard, Chr(2))
    EndIf
    count_bits = CountWords2(pattern, wildcard)
    For i = 1 To count_bits
        bit$    = GetWord2(pattern, i, wildcard)
        bit     = Replace(bit, Chr(1), escape)
        bit     = Replace(bit, Chr(2), wildcard)
        position= InStr(compare, bit, position)
        If position = 0 Then Return False
        If i = 1 And position > 1 And Left(pattern,1) <> wildcard Then Return False
        If i = count_bits And position < Len(compare) - Len(bit) + 1 And Right(pattern,1) <> wildcard Then Return False
    Next i
    Return True
EndFunction


// Copied 2021-02-12 from http://www.cbrepository.com/codes/code/94/
// Created 2014-12-26 by Jare
// Modifications: Made the function FVD compatible
Function IReplace(haystack$, find$, replace_$)
	Dim haystack2$, position, result$, old_position // Force Variable Declaration
	
	haystack2$	= Lower(haystack)
	find		= Lower(find)
	position	= InStr(haystack2, find)
	result$		= ""
	old_position= 1
	While position
		result		= result + Mid(haystack, old_position, position-old_position) + replace_$
		old_position= position + Len(find)
		position	= InStr(haystack2, find, old_position)
	Wend
	result = result + Mid(haystack, old_position)
	Return result
EndFunction


// Copied 2021-02-12 http://www.cbrepository.com/codes/code/93/
// Created 2014-12-25 by Jare
// Modifications: Made the function FVD compatible
Function GetBetween$(haystack$, start$, stop$, notfound$="")
	Dim a, b // Force Variable Declaration
	
	a = InStr(haystack, start)
	b = InStr(haystack, stop, a+1)
	If a = 0 Or b = 0 Then Return notfound
	Return Mid(haystack, a+Len(start), b-(a+Len(start)))
EndFunction


// Copied 2021-02-12 from http://www.cbrepository.com/codes/code/11/
// Created 2011-04-09 by KilledWhale
// Modifications:
//  - added $ to the GetWord2() function name. No other modifications
//  - Made the function FVD compatible
Function GetWord2$(a As String, b As Integer, c As String)
   Dim l, i, q // Force Variable Declaration
   
   l = Len(c) // Otetaan pituus muuttujaan optimoinniksi
	For i As Integer = 2 To b // Käydään läpi kaikki ei-halutut sanat
	  q = InStr(a, c) // Katsotaan löytyykö erotinta
		If q Then // Löytyi
			a = Mid(a, q + l) // Otetaan alkuosa pois erottimeen asti
	  EndIf
	Next i

   q = InStr(a, c) // Katsotaan vielä löytyykö erotinta
	If q Then // Jos löytyi
		Return Mid(a, 1, q - 1) // Palautetaan tekstiä seuraavaan erottimeen asti
	Else // Ei löytynyt
		Return Mid(a, 1) // Palautetaan loppuosa
	EndIf
EndFunction

// Copied 2021-02-12 from http://www.cbrepository.com/codes/code/11/
// Created 2011-04-09 by KilledWhale
// Modifications: Made the function FVD compatible
Function CountWords2(a As String, c As String)
   Dim n, aa // Force Variable Declaration
   
   Repeat
	  n + 1 // Kasvatetaan arvoa, että montako ON löydetty
	  aa = InStr(a, c, aa + 1) // Katsotaan löytyykö erotinta
	  If Not aa Then // Jos ei löydy
		 Exit // Poistutaan
	  EndIf
   Forever
   Return n // Palautetaan esiintymien määrä
EndFunction


// Saved 2021-02-13 to http://www.cbrepository.com/codes/code/104/ (the same time that I wrote it in this file)
// Modifications: Made the function FVD compatible
//
// Does the following cleanups to the given path:
// - Resolves .. in directory paths (if possible)
// - Converts / to \
// - Converts double \\ to \
// The second parameter is used to determine whether you want the path to end with a backslash or not (True/False).
Function CleanPath(path$, end_with_backslash=0)
	Dim position, path_start$, path_end$, i, character$ // Force Variable Declaration
	
	path = Replace(path, "/", "\")
	path = Replace(path, "\\", "\")
	
	// Resolve possible ".." folders (= references To parent folders)
	position=1
	While InStr(path, "\..", position)
		position = InStr(path, "\..", position)
		path_start$ = Left(path, position-1) // Contains a trailing folder name that we need To remove later. Does Not contain a trailing backslash.
		path_end$ = Mid(path, position+Len("\..\")) // Might be an empty String
		
		If Right(path_start,2) = ".." Then
			// path_start ends with a ..
			// This means that we have found a ../.. reference.
			// Do Not remove it because we only come here If the ../.. reference was in the beginning of the path.
			position+1
		Else
			// path_start has a regular folder name at the End of it
			// Remove the Last folder from path_start
			For i = Len(path_start) To 1 Step -1
				character$ = Mid(path_start,i,1)
				If character = "\" Then
					path_start = Left(path_start,i) // Will Include a trailing backslash
					Exit
				ElseIf i = 1 Then
					path_start = ""
					Exit
				EndIf
			Next i
			
			// Slice foldername\.. out from middle of path
			path = path_start + path_end
			position = 1 // Make sure to start the Next InStr() check from the beginning
		EndIf
	Wend
	
	If end_with_backslash Then
		If Right(path,1) <> "\" Then path + "\"
	Else
		If Right(path,1) = "\" Then path = Left(path,Len(path)-1) // Remove the backslash
	EndIf
	Return path
EndFunction


//
// Saved 2021-02-20 to http://www.cbrepository.com/codes/code/105/ (the same time that I wrote it in this file)
// Modifications: None
//
Function IsAbsolutePath(path$)
	Dim first_character$, second_character$ // Force Variable Declaration
	
	If Len(path) < 2 Then Return False // A path that is so small is probably a one letter folder Or just . Or an empty String.
	first_character = Left(path, 1)
	second_character = Mid(path, 2,1)
	If Asc(Upper(first_character)) >= 65 And Asc(Upper(first_character)) <= 90 And second_character = ":" Then
		// The path is something like "C:", so it's absolute
		Return True
	ElseIf first_character = "\" And second_character = "\" Then
		// The path is a network path, beginning with \\, so it's absolute
		Return True
	Else
		// The path is something Else, so probably relative
		Return False
	EndIf
EndFunction


// The following type and two functions are copied 2021-02-20 from http://www.cbrepository.com/codes/code/14/
// Created 2011-04-09 by: Jare (edited 2021-02-20)
// Modifications: None because all modifications are now saved back to cbrepository.com
Type FoundFile
	Field name As String
	Field directory As String
	Field absolute_path As String
EndType
Type FoundFolder
	Field name As String
	Field directory As String
	Field absolute_path As String
	Field isNew As Byte
EndType
Function listFiles(directory$="", extension$="", recursive=1, reset=1)
	//extension$ = which Type of files To search For. example: "txt" (without Dot). Leave empty If you want To find all files.

	Dim orig_dir$, filename$ // Force Variable Declaration
	Dim f.FoundFile, fo.FoundFolder
	
	If reset Then
		// Forget old files
		For f = Each FoundFile
			Delete f
		Next f
	EndIf
	
	orig_dir$ = CurrentDir()
	If Not IsDirectory(directory) Then Return False
	ChDir directory
	StartSearch
	Repeat
		filename$ = FindFile()
		If IsDirectory(filename)=False And (Lower(Str(getFileExtension(filename))) = extension Or extension = "") Then
			f				= New(FoundFile)
			f\name			= filename
			f\directory		= CurrentDir()
			f\absolute_path = CurrentDir()+filename
		ElseIf (IsDirectory(filename) And filename <> "." And filename <> "..") Then
			fo				= New(FoundFolder)
			fo\name			= filename
			fo\directory	= CurrentDir()
			fo\absolute_path= CurrentDir()+filename
			fo\isNew		= True
		EndIf
	Until filename = ""
	EndSearch
	
	If recursive Then
		For fo = Each FoundFolder
			If (fo\isNew) Then
				fo\isNew = False
				listFiles(fo\absolute_path, extension, True, False)
			EndIf
		Next fo
	EndIf
	
	ChDir orig_dir
	Return True
EndFunction
Function getFileExtension(filename$)
	Dim i, char$, extension$ // Force Variable Declaration
	
	For i = Len(filename) To 1 Step -1
		char$ = Mid(filename, i,1)
		If (char = ".") Then
			Return extension$
		Else
			extension = char + extension
		EndIf
	Next i
	Return "" 'No extension
EndFunction


// Saved 2021-03-06 to http://www.cbrepository.com/codes/code/106/ (the same time that I wrote it in this file)
// Modifications: None
//
// Opens a file in read mode and finds the desired line number and returns the line string.
// Parameters:
// - file_path$: The file name that should be read.
// - line_number: The line number that we want to get. Starts from one. Defaults to one.
// - if_no_file: What to return if the file does not exist. Defaults to an empty string.
// - if_no_line: What to return if the file exists but if it does not have enough lines. Defaults to an empty string.
//
Function ReadLineFromFile(file_path$, line_number = 1, if_no_file$="", if_no_line$="")
	Dim file, current_line$, current_line_number
	
	If FileExists(file_path) Then
		file = OpenToRead(file_path)
		current_line_number = 0
		While Not EOF(file)
			current_line = ReadLine(file)
			current_line_number + 1
			If current_line_number = line_number Then
				CloseFile file
				Return current_line
			EndIf
		Wend
		CloseFile file
		Return if_no_line
	Else
		Return if_no_file
	EndIf
EndFunction
